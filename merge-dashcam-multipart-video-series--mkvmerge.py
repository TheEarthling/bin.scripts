#!/usr/bin/env python3

# BUGS :
#  - FIXED? overwrites already existing *.mkvmerged.mkv files when already exists, but not always...

# IMPROVEMENTS :
#  - seems like ffmpeg might be the proper tool to use, which appears to
#  result in files that are the exact same kind from which they came.
#  - allow specifying to overwrite already existing files that appear to be
#  already merged created.

# ASSUMPTIONS :
#  - not tested with spaces in specified path (the -p argument).
#  - video files are properly timestamped (basically, if your dashcam isnt bonkers and created them normally and havent been modified after the fact, this should be automatically satisfied.  at a minimum, files apart of a multipart video set should be chronologically created.
#  - mkvmerge is somewhere in PATH.
#  - video files can be combined using mkvmerge.
#  - specified path only contains videos generated by device and not a bunch of
#  other unrelated files or directories. (not tested for this situation)

# global variable; using the filename of the first video in a series + the following string = the merged video file.
G_MERGED_FILENAME_SUFFIX = "mkvmerged.mkv"

def executeCommandLine( command ):
    rc = subprocess.run( shlex.split( command ) )
    return rc


# TODO s/basefilename/filename/globally (from the variable name, this was an incorrect assumption I made)
def generateMkvmergedFilename( basefilename ):
    return ("%s.%s" % (basefilename, G_MERGED_FILENAME_SUFFIX) )

# does the passed filename look like a merged file or a raw/original source file?
def isMkvmergedFilename( basefilename ):
    testSuffix = basefilename[ - len( G_MERGED_FILENAME_SUFFIX ) : ]
    isMkvmergedFilenameDisposition = testSuffix == G_MERGED_FILENAME_SUFFIX
    return isMkvmergedFilenameDisposition


# the start and end indices of the list of files that are members of the set, inclusive.
def generateMkvmergeCmdln( fileArray, start, end ):
    end += 1
    cmdlnBuilding0 = "mkvmerge -o"
    cmdlnBuilding1 = generateMkvmergedFilename( fileArray[start] )
    cmdlnBuilding2 = (" + ".join(fileArray[start:end]))
    return ("%s %s %s" % (cmdlnBuilding0, cmdlnBuilding1, cmdlnBuilding2) )


def handleSingleOrEndOfASetFile( fileArray, start, end ):
    pass


import os
import glob
import optparse
import shlex, subprocess

parser = optparse.OptionParser()
#parser.add_option("-p", "--path", help="path that contains mkvmerge-able files", dest="search_dir")
parser.add_option("-p", "--path", help="path that contains mkvmerge-able files", dest="search_dir", default=".")
parser.add_option("-n", help="dry-run; dont actually do anything, just show", action="store_true", dest="isDryRun", default=False)

(options, arguments) = parser.parse_args()

import pprint
pprint.pprint(options)

#files = filter(os.path.isfile, glob.glob(options.search_dir + "*"))         # Python 2
files = list( filter(os.path.isfile, glob.glob(options.search_dir + "*")) )  # Python 3
files.sort(key=lambda x: os.path.getmtime(x))

beginningSetIndex = 0
for i in range(0, len(files)):
    print("%s" % files[i])

    # check that curr file doesnt have the suffix .mkvmerged.mkv
    if isMkvmergedFilename( files[i] ):
        # it does. skip this loop iteration.
        print("# ^looks like an already existing mkvmerge.\n")
        continue


    if i + 1 < len( files ):  # "if this isn't the last element in the list ..."

        if files[i + 1][ -7: ] == '001.MOV':  # "if this isnt the middle of a set..."
            # if got here, its either:
            #   - a solo; notify and do nothing more.
            #   - the last of a set; determine cmdln string and execute.


            # handleSingleOrEndOfASetFile( files, beginningSetIndex, i )

            if beginningSetIndex == i:  # "if this is a solo..."
                # basically noop.
                print("# ^single file; no mkvmergeing to do.")

            else:  # "if this is the last of a set..."
                generatedFilename = generateMkvmergedFilename( files[ beginningSetIndex ] )

                # check if generated filename already exists; wont overwrite (unless forced?)
                generatedFilenameDNE = not os.path.isfile( generatedFilename )

                #if generatedFilenameDNE: then continue here
                if generatedFilenameDNE:
                    helpingNote = ("touch --reference %s %s" % ( files[ beginningSetIndex ], generatedFilename ) )
                    print( helpingNote )

                    cmdln = generateMkvmergeCmdln( files, beginningSetIndex, i )

                    if options.isDryRun:
                        print( cmdln )
                    else:
                       executeCommandLine( cmdln )
                else:
                    print("# looks like an mkvmerge file already exists.  not doing anything.")

            # forward progress:
            beginningSetIndex = i + 1


        else:
            print( "# ^files[i] is NOT solo ; it continues a set (inclusively).")


    else:  # "this is the last item in the list"

        #### FROM HERE DOWN
        if beginningSetIndex == i:  # "if this is a solo..."
            # basically noop.
            print("# ^single file; no mkvmergeing to do.")

        else:  # "if this is the last of a set..."
            generatedFilename = generateMkvmergedFilename( files[ beginningSetIndex ] )

            # check if generated filename already exists; wont overwrite (unless forced?)
            generatedFilenameDNE = not os.path.isfile( generatedFilename )

            #if generatedFilenameDNE: then continue here
            if generatedFilenameDNE:
                helpingNote = ("touch --reference %s %s" % ( files[ beginningSetIndex ], generatedFilename ) )
                print( helpingNote )

                cmdln = generateMkvmergeCmdln( files, beginningSetIndex, i )

                if options.isDryRun:
                    print( cmdln )
                else:
                   executeCommandLine( cmdln )
            else:
                print("# looks like an mkvmerge file already exists.  not doing anything.")

        #### FROM HERE UP...
        # ... could convert to function since they indentical within both uses.

    print("")

