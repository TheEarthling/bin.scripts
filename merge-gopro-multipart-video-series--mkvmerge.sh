#!/bin/bash -p
#===============================================================================
#          FILE:  merge-multipart-video-series-gopro2.sh
#         USAGE:  <see f_usage()>
#   DESCRIPTION:  <see f_usage()>
#       OPTIONS:  <see f_usage()>
#  REQUIREMENTS:  ---
#          BUGS:  ---
#         NOTES:  ---
#        AUTHOR:   (),
#       COMPANY:
#       VERSION:  1.0
#       CREATED:  2016-09-17T11:16:18-0400
#      REVISION:  ---
#===============================================================================
set -o xtrace                               # After expanding each simple command, for command, case command, select command, or arithmetic for command, display the expanded value of PS4, followed by the command and its expanded arguments or associated word list.
PS4=' { ${LINENO} } '                       # The value of this parameter is expanded as with PS1 and the value is printed before each command bash displays during an execution trace.  The first character of PS4 is replicated multiple times, as necessary, to indicate multiple levels of indirection.  The default is ``+ ''.
#set -o errexit                              # Exit immediately if a pipeline (which may consist of a single simple command), a subshell command enclosed in parentheses, or one of the commands executed as part of a command list enclosed by braces (see SHELL GRAMMAR above) exits with a non-zero status.
set -o nounset                              # Treat unset variables as an error
set -o pipefail                             # with pipefail enabled, the pipelines return status is the value of the last (rightmost) command to exit with a non-zero status, or zero if all commands exit successfully.

f_usage(){
   local scriptname="$( basename "$0" )"
   cat <<__usageHEREDOC__
Usage: $scriptname <top-level-path>

This script joins those multiple 4GiB splitted video files that are
generated by recording devices such as a gopro.

These devices split the files because you were forced to
record onto the drivel filled filesystem still in use today
that we should have abandoned in like 1998 and a half... also
known as fat32.

top-level-path should contain (somewhere, not necessarily immediately within)
a video series.  This script is expecting a format something like this:
   GOPR1431.MP4
   GP011431.MP4
   GP021431.MP4
   GP031431.MP4
   GP041431.MP4
which represent a single recording session.  This script will create a single
joined video file using mkvmerge.
__usageHEREDOC__
   exit 1
}


#if [[ $# != 1 ]] && [[ $# != 4 ]] ; then
if [[ $# != 1 ]] ; then
   echo "ERROR: $# is not enough cmdln arguments"
   f_usage
fi



#
# PARSE CMDLN, VARIABLE DEFINITIONS, SANITY CHECKS && META GENERATION
#====================================================================
#
loopcount=0
while [ "$#" -gt "0" ] ; do
   case $1 in
      #--block-size=?*) # specified like: --key=value
      #   BLOCKSIZE=${1#--block-size=}
      #   shift
      #   ;;
      #-b) # specified like: -k value
      #   BLOCKSIZE=$2
      #   shift 2
      #   ;;
      #-b|--block-size) # specified like: -k value, or like: --key value
      #   BLOCKSIZE=$2
      #   shift 2
      #   ;;
      #-q|--quiet) # specified like: -k, or like: --key
      #   ISQUIET="TRUE"
      #   shift
      #   ;;
      -u|--usage|-h|--help) # specified like: -k, or like: --key
         f_usage
         ;;
      *) # if user input didn't match any of the prior flags,
         # going to assume it's the starting path. A sanity
         # check will be performed after all cmdln args parsed.
         INPUT_PATH=$1
         shift
         ;;
      #--*=?*) # specified like: --key=value
      #   # $this --key1=value1   ends up defining "key1" with "value1"

      #   # for example: --xyz=abc
      #   value=${1#--*=}  # abc
      #   tmp=${1%=*}
      #   key=${tmp#--}    # xyz

      #   # set the variable xyz to abc
      #   eval ${key}="\"${value}\""

      #   # TODO STUB: development print::
      #   #echo "DEFINED VARIABLE BASED ON PARSE FROM CMDLN : ${key}=\"${value}\""
      #   shift
      #   ;;
   esac

   let loopcount+=1
   if [[ $loopcount = 40 ]] ; then
      echo "problem parsing cmdln args.  entered infinite loop.  bai."
      exit 5
   fi
done

#     <perhaps some test conditions make sense to check inputs, prior to the main
#      variable param/error block...>
: ${INPUT_PATH:?ERROR: INPUT_PATH variable must be set}
# Is this path garbage or not?  bail if so.
test -d "$INPUT_PATH" >/dev/null  2>&1
if [[ $? != 0 ]] ; then
   echo "ERROR: $INPUT_PATH failed a 'test -d'... bai."
   exit 2
fi



#
# VARIABLE PARAMS/INITIALIZATION AND SANITY CHECKING
#====================================================================
#
# vars to define if not defd; think "<cfparam=*..."
: ${ISQUIET:="FALSE"}
: ${ISFORCED:="FALSE"}
: ${TEMPDIR:=/tmp}

# required to be defined by now; think "<cfparam=* required=yes..."
#: ${TEMPDIR2:?ERROR: not specified}


#
# FUNCTIONS AND ANY OTHER PRE-MAIN
#====================================================================
#
f_control_c(){
   # c-c was entered.
   #echo -en "\n*** Ouch! Exiting ***\n"
   exit 1
}

# trap keyboard interrupt (control-c)
trap f_control_c SIGINT

# alternatively,
#trap exit SIGINT SIGTERM


#if [ -n "${ISQUIET}" ] ; then
if [ x"${ISQUIET}" = x"TRUE" ] ; then
    exec &>/dev/null
fi


#
# MAIN
#====================================================================
#

#find . -name *GP01*\.MP4
#./t23-20160909-185826/DCIM/100GOPRO/GP011431.MP4
#
#cd /mnt/a123/fs1/gopro-data
#i=./t23-20160909-185826/DCIM/100GOPRO/GP011431.MP4
#echo $i
#./t23-20160909-185826/DCIM/100GOPRO/GP011431.MP4
#
#cd $( dirname $i)
#j=$( basename $i)
#echo $j
#GP011431.MP4
#
#rhs=$( echo ${j##GP01})
#rhs=$( echo ${rhs:: -4})
#[teelah@ipoowid 100GOPRO]$ echo $rhs
#1431
#
#[teelah@ipoowid 100GOPRO]$ ls *${rhs}.MP4
#<^^^THESE ARE THE VIDEOS TO BE JOINED, IN SEQUENTIAL ORDER>
#GOPR1431.MP4*  GP011431.MP4*  GP021431.MP4*  GP031431.MP4*  GP041431.MP4*
#--------------------------------------------------------------------------------

# "GP01*.MP4" is the 2nd file in a single video recording series that have been
# split up because of some cat rapey filesystem still in use today that we
# should have f*#$%^& abandoned in like 2000.
#IFS=$(echo -en "\n\b")
#for i in $( find "$INPUT_PATH" -name GP01\*\.MP4 ) ; do
#for i in "$( find "$INPUT_PATH" -name GP01\*\.MP4 )" ; do
find "$INPUT_PATH" -name GP01\*\.MP4 | while read i ; do
   #i=./t23-20160909-185826/DCIM/100GOPRO/GP011431.MP4
      #echo "cwd: $( pwd )"

   cd "$( dirname "$i" )"
      echo -e "\ncwd: $( pwd )"

   j="$( basename "$i" )"
   #GP011431.MP4

   rhs=${j##GP01}
   #1431.MP4

   rhs=${rhs:: -4}   # THIS MIGHT NOT BE NECESSARY.
   #1431

   #ls *${rhs}.MP4 -tr1
   #GOPR1431.MP4*  GP011431.MP4*  GP021431.MP4*  GP031431.MP4*  GP041431.MP4*
   filestojoinlist=""
   for currfile in $( ls *${rhs}.MP4 -tr1 ) ; do filestojoinlist=$( echo "$filestojoinlist" + "$currfile" ); done

   # remove leading "+":
   filestojoinlist=${filestojoinlist:2}

   firstinseries=$( ls *${rhs}.MP4 -tr1 | head -1 )
   mergedfile="${firstinseries}-mkvmerged.mkv"

   # mkvmerge will gladly overwrite already existing files... so don't do that:
   if [[ -f "${mergedfile}" ]] ; then
      echo "$( pwd )/${mergedfile} already exists."
      cd - >/dev/null
      continue
   else
      #<CREATE AN OUTPUT FILE NAMED: GOPR1432.MP4-mkvmerged.mkv>
      #time echo mkvmerge -o  "${j}-mkvmerged.mkv"  "$filestojoinlist"
      echo "executing: mkvmerge -o  ${mergedfile}  $filestojoinlist"
      mkvmerge -o  "${mergedfile}"  $( echo $filestojoinlist )

      cd - >/dev/null
   fi
done

